// -*- c -*-
//
// %CopyrightBegin%
//
// Copyright Ericsson AB 2017-2020. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// %CopyrightEnd%
//

return_trace() {
    ErtsCodeMFA* mfa = (ErtsCodeMFA *)(E[1]);

    SWAPOUT;		/* Needed for shared heap */
    ERTS_UNREQ_PROC_MAIN_LOCK(c_p);
    erts_trace_return(c_p, mfa, r(0), ERTS_TRACER_FROM_ETERM(E+2)/* tracer */);
    ERTS_REQ_PROC_MAIN_LOCK(c_p);
    SWAPIN;
    E += 3;
    $RETURN();
    Goto(*I);
    //| -no_next
}

i_generic_breakpoint() {
    BeamInstr real_I;
    HEAVY_SWAPOUT;
    real_I = erts_generic_breakpoint(c_p, erts_code_to_codeinfo(I), reg);
    HEAVY_SWAPIN;
    ASSERT(VALID_INSTR(real_I));
    Goto(real_I);
    //| -no_next
}

i_return_time_trace() {
    ErtsCodeInfo *cinfo = (!is_CP(E[1]) ? NULL : erts_code_to_codeinfo((BeamInstr*)E[1]));
    SWAPOUT;
    erts_trace_time_return(c_p, cinfo);
    SWAPIN;
    E += 2;
    $RETURN();
    Goto(*I);
    //| -no_next
}

i_return_to_trace() {
    if (IS_TRACED_FL(c_p, F_TRACE_RETURN_TO)) {
        Uint *cpp = (Uint*) E;
        while (is_not_CP(*cpp)) {
            cpp++;
        }
        for(;;) {
            if (IsOpCode(*cp_val(*cpp), return_trace)) {
                do
                    ++cpp;
                while (is_not_CP(*cpp));
                cpp += 2;
            } else if (IsOpCode(*cp_val(*cpp), i_return_to_trace)) {
                do
                    ++cpp;
                while (is_not_CP(*cpp));
            } else {
                break;
            }
        }
        SWAPOUT;		/* Needed for shared heap */
        ERTS_UNREQ_PROC_MAIN_LOCK(c_p);
        erts_trace_return_to(c_p, cp_val(*cpp));
        ERTS_REQ_PROC_MAIN_LOCK(c_p);
        SWAPIN;
    }
    E += 1;
    $RETURN();
    Goto(*I);
    //| -no_next
}

i_debug_breakpoint() {
    HEAVY_SWAPOUT;
    I = call_error_handler(c_p, erts_code_to_codemfa(I), reg, am_breakpoint);
    HEAVY_SWAPIN;
    if (I) {
        Goto(*I);
    }
    goto handle_error;
    //| -no_next
}



//
// Special jump instruction used for tracing. Takes an absolute
// failure address.
//

trace_jump(Fail) {
    //| -no_next
    SET_I((BeamInstr *) $Fail);
    Goto(*I);
}
