// -*- c -*-
//
// %CopyrightBegin%
//
// Copyright Ericsson AB 2017-2018. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// %CopyrightEnd%
//

//
// Stack manipulation instructions follow.
//
// See the comment for AH() in macros.tab for information about
// the layout of stack frames.
//

i_validate(Arity) {
    (void)$Arity;
}

x64.i_validate(Arity);

allocate(NeedStack, Live) {
    $AH($NeedStack, 0, $Live);
}

x64.allocate(NeedStack, Live);

allocate_heap(NeedStack, NeedHeap, Live) {
    $AH($NeedStack, $NeedHeap, $Live);
}

x64.allocate_heap(NeedStack, NeedHeap, Live);

allocate_zero(NeedStack, Live) {
    Eterm* ptr;
    int i = $NeedStack;
    $AH(i, 0, $Live);
    for (ptr = E + i; ptr > E; ptr--) {
	 make_blank(*ptr);
    }
}

x64.allocate_zero(NeedStack, Live);

allocate_heap_zero(NeedStack, NeedHeap, Live) {
    Eterm* ptr;
    int i = $NeedStack;
    $AH(i, $NeedHeap, $Live);
    for (ptr = E + i; ptr > E; ptr--) {
        make_blank(*ptr);
    }
}

x64.allocate_heap_zero(NeedStack, NeedHeap, Live);

// This instruction is probably never used (because it is combined with a
// a return). However, a future compiler might for some reason emit a
// deallocate not followed by a return, and that should work.

deallocate(Deallocate) {
    //| -no_prefetch
    E = ADD_BYTE_OFFSET(E, $Deallocate);
}

x64.deallocate(Deallocate);

return() {
    //| -no_next
    DTRACE_RETURN_FROM_PC(c_p, I);
    $RETURN();
    CHECK_TERM(r(0));
    HEAP_SPACE_VERIFIED(0);

    $DISPATCH_RETURN();
}

x64.return();

//
// Micro-benchmarks showed that the deallocate_return instruction
// became slower when the continuation pointer was moved from
// the process struct to the stack. The reason seems to be read
// dependencies, i.e. that the CPU cannot figure out beforehand
// from which position on the stack the continuation pointer
// should be fetched.
//
// Initializing num_bytes with a constant value seems to restore
// the lost speed, so we've specialized the instruction for the
// most common values.
//

// Call instructions

i_call(CallDest) {
    //| -no_next
    $SAVE_CONTINUATION_POINTER($NEXT_INSTRUCTION);
    $DISPATCH_REL($CallDest);
}

x64.i_call(CallDest);

i_call_last(CallDest, Deallocate) {
    //| -no_next
    $deallocate($Deallocate);
    $DISPATCH_REL($CallDest);
}

x64.i_call_last(CallDest, Deallocate);

i_call_only(CallDest) {
    //| -no_next
    $DISPATCH_REL($CallDest);
}

x64.i_call_only(CallDest);

i_call_ext(Dest) {
    //| -no_next
    $SAVE_CONTINUATION_POINTER($NEXT_INSTRUCTION);
    $DISPATCH_EXPORT($Dest);
}

x64.i_call_ext(Dest);

i_call_ext_only(Dest) {
    //| -no_next
    $DISPATCH_EXPORT($Dest);
}

x64.i_call_ext_only(Dest);

i_call_ext_last(Dest, Deallocate) {
    //| -no_next
    $deallocate($Deallocate);
    $DISPATCH_EXPORT($Dest);
}

x64.i_call_ext_last(Dest, Deallocate);

APPLY(I, Deallocate, Next) {
    //| -no_next
    HEAVY_SWAPOUT;
    $Next = apply(c_p, reg, $I, $Deallocate);
    HEAVY_SWAPIN;
}

HANDLE_APPLY_ERROR() {
    I = handle_error(c_p, I, reg, bif_trap_export[BIF_apply_3].info.mfa);
    goto post_error_handling;
}

i_apply() {
    //| -no_next
    BeamInstr *next;
    $APPLY(NULL, 0, next);
    if (ERTS_LIKELY(next != NULL)) {
        $SAVE_CONTINUATION_POINTER($NEXT_INSTRUCTION);
        $DISPATCH_ABS(next);
    }
    $HANDLE_APPLY_ERROR();
}

x64.i_apply();

i_apply_last(Deallocate) {
    //| -no_next
    BeamInstr *next;
    $APPLY(I, $Deallocate, next);
    if (ERTS_LIKELY(next != NULL)) {
        $deallocate($Deallocate);
        $DISPATCH_ABS(next);
    }
    $HANDLE_APPLY_ERROR();
}

x64.i_apply_last(Deallocate);

i_apply_only() {
    //| -no_next
    BeamInstr *next;
    $APPLY(I, 0, next);
    if (ERTS_LIKELY(next != NULL)) {
        $DISPATCH_ABS(next);
    }
    $HANDLE_APPLY_ERROR();
}

x64.i_apply_only();

FIXED_APPLY(Arity, I, Deallocate, Next) {
    //| -no_next
    HEAVY_SWAPOUT;
    $Next = fixed_apply(c_p, reg, $Arity, $I, $Deallocate);
    HEAVY_SWAPIN;
}

apply(Arity) {
    //| -no_next
    BeamInstr *next;
    $FIXED_APPLY($Arity, NULL, 0, next);
    if (ERTS_LIKELY(next != NULL)) {
        $SAVE_CONTINUATION_POINTER($NEXT_INSTRUCTION);
        $DISPATCH_ABS(next);
    }
    $HANDLE_APPLY_ERROR();
}

x64.apply(Arity);

apply_last(Arity, Deallocate) {
    //| -no_next
    BeamInstr *next;
    $FIXED_APPLY($Arity, I, $Deallocate, next);
    if (ERTS_LIKELY(next != NULL)) {
        $deallocate($Deallocate);
        $DISPATCH_ABS(next);
    }
    $HANDLE_APPLY_ERROR();
}

x64.apply_last(Arity, Deallocate);

APPLY_FUN(Next) {
    HEAVY_SWAPOUT;
    $Next = apply_fun(c_p, r(0), x(1), reg);
    HEAVY_SWAPIN;
}

HANDLE_APPLY_FUN_ERROR() {
     goto find_func_info;
}

i_apply_fun() {
    //| -no_next
    BeamInstr *next;
    $APPLY_FUN(next);
    if (ERTS_LIKELY(next != NULL)) {
        $SAVE_CONTINUATION_POINTER($NEXT_INSTRUCTION);
        $DISPATCH_FUN(next);
    }
    $HANDLE_APPLY_FUN_ERROR();
}

x64.i_apply_fun();

i_apply_fun_last(Deallocate) {
    //| -no_next
    BeamInstr *next;
    $APPLY_FUN(next);
    if (ERTS_LIKELY(next != NULL)) {
        $deallocate($Deallocate);
        $DISPATCH_FUN(next);
    }
    $HANDLE_APPLY_FUN_ERROR();
}

x64.i_apply_fun_last(Deallocate);

i_apply_fun_only() {
    //| -no_next
    BeamInstr *next;
    $APPLY_FUN(next);
    if (ERTS_LIKELY(next != NULL)) {
        $DISPATCH_FUN(next);
    }
    $HANDLE_APPLY_FUN_ERROR();
}

x64.i_apply_fun_only();

CALL_FUN(Fun, Next) {
    //| -no_next
    HEAVY_SWAPOUT;
    $Next = call_fun(c_p, $Fun, reg, THE_NON_VALUE);
    HEAVY_SWAPIN;
}

i_call_fun(Fun) {
    //| -no_next
    BeamInstr *next;
    $CALL_FUN($Fun, next);
    if (ERTS_LIKELY(next != NULL)) {
        $SAVE_CONTINUATION_POINTER($NEXT_INSTRUCTION);
        $DISPATCH_FUN(next);
    }
    $HANDLE_APPLY_FUN_ERROR();
}

x64.i_call_fun(Fun);

i_call_fun_last(Fun, Deallocate) {
    //| -no_next
    BeamInstr *next;
    $CALL_FUN($Fun, next);
    if (ERTS_LIKELY(next != NULL)) {
        $deallocate($Deallocate);
        $DISPATCH_FUN(next);
    }
    $HANDLE_APPLY_FUN_ERROR();
}

x64.i_call_fun_last(Fun, Deallocate);

get_list(Src, Hd, Tl) {
    Eterm* tmp_ptr = list_val($Src);
    Eterm hd, tl;
    hd = CAR(tmp_ptr);
    tl = CDR(tmp_ptr);
    $Hd = hd;
    $Tl = tl;
}

x64.get_list(Src, Hd, Tl);

get_hd(Src, Hd) {
    Eterm* tmp_ptr = list_val($Src);
    $Hd = CAR(tmp_ptr);
}

x64.get_hd(Src, Tl);

get_tl(Src, Tl) {
    Eterm* tmp_ptr = list_val($Src);
    $Tl = CDR(tmp_ptr);
}

x64.get_tl(Src, Tl);

i_get(Src, Dst) {
    $Dst = erts_pd_hash_get(c_p, $Src);
}

x64.i_get(Src, Dst);

i_get_hash(Src, Hash, Dst) {
    $Dst = erts_pd_hash_get_with_hx(c_p, $Hash, $Src);
}

x64.i_get_hash(Src, Hash, Dst);

i_get_tuple_element(Src, Element, Dst) {
    Eterm* src = ADD_BYTE_OFFSET(tuple_val($Src), $Element);
    $Dst = *src;
}

x64.i_get_tuple_element(Src, Element, Dst);

init(Y) {
    make_blank($Y);
}

x64.init(Y);

i_make_fun(FunP, NumFree) {
    HEAVY_SWAPOUT;
    x(0) = new_fun(c_p, reg, (ErlFunEntry *) $FunP, $NumFree);
    HEAVY_SWAPIN;
}

x64.i_make_fun(FunP, NumFree);

i_trim(Words) {
    E += $Words;

    /*
     * Clear the reserved location for the continuation pointer at
     * E[0]. This is not strictly necessary for correctness, but if a
     * GC is triggered before E[0] is overwritten by another
     * continuation pointer the now dead term at E[0] would be
     * retained by the GC.
     */
    E[0] = NIL;
}

x64.i_trim(Words);

move(Src, Dst) {
    $Dst = $Src;
}

x64.move(Src, Dst);

node(Dst) {
    $Dst = erts_this_node->sysname;
}

x64.node(Dst);

put_list(Hd, Tl, Dst) {
    HTOP[0] = $Hd;
    HTOP[1] = $Tl;
    $Dst = make_list(HTOP);
    HTOP += 2;
}

x64.put_list(Hd, Tl, Dst);

update_list(Hd, Dst) {
    HTOP[0] = $Hd;
    HTOP[1] = $Dst;
    $Dst = make_list(HTOP);
    HTOP += 2;
}

x64.update_list(Hd, Dst);

put_tuple2(Dst, Arity) {
    Eterm* hp = HTOP;
    Eterm arity = $Arity;

    /*
     * If operands are not packed (in the 32-bit VM),
     * is is not safe to use $Dst directly after I
     * has been updated.
     */
    Eterm* dst_ptr = &($Dst);

    //| -no_next
    ASSERT(arity != 0);
    *hp++ = make_arityval(arity);
    I = $NEXT_INSTRUCTION;
    do {
        Eterm term = *I++;
        switch (loader_tag(term)) {
        case LOADER_X_REG:
            *hp++ = x(loader_x_reg_index(term));
            break;
        case LOADER_Y_REG:
            *hp++ = y(loader_y_reg_index(term));
            break;
        default:
            *hp++ = term;
            break;
        }
    } while (--arity != 0);
    *dst_ptr = make_tuple(HTOP);
    HTOP = hp;
    ASSERT(VALID_INSTR(* (Eterm *)I));
    Goto(*I);
}

x64.put_tuple2(Dst, Arity);

self(Dst) {
    $Dst = c_p->common.id;
}

x64.self(Dst);

set_tuple_element(Element, Tuple, Offset) {
    Eterm* p;

    ASSERT(is_tuple($Tuple));
    p = (Eterm *) ((unsigned char *) tuple_val($Tuple) + $Offset);
    *p = $Element;
}

x64.set_tuple_element(Element, Tuple, Offset);

swap(R1, R2) {
    Eterm V = $R1;
    $R1 = $R2;
    $R2 = V;
}

x64.swap(R1, R2);

test_heap(Nh, Live) {
    $GC_TEST(0, $Nh, $Live);
}

x64.test_heap(Nh, Live);

is_nonempty_list(Fail, Src) {
    //| -no_prefetch
    if (is_not_list($Src)) {
        $FAIL($Fail);
    }
}

x64.is_nonempty_list(Fail, Src);

jump(Fail) {
    $JUMP($Fail);
}

x64.jump(Fail);

//
// Test instructions.
//

is_atom(Fail, Src) {
    if (is_not_atom($Src)) {
        $FAIL($Fail);
    }
}

x64.is_atom(Fail, Src);

is_boolean(Fail, Src) {
    if (($Src) != am_true && ($Src) != am_false) {
        $FAIL($Fail);
    }
}

x64.is_boolean(Fail, Src);

is_binary(Fail, Src) {
    if (is_not_binary($Src) || binary_bitsize($Src) != 0) {
        $FAIL($Fail);
    }
}

x64.is_binary(Fail, Src);

is_bitstring(Fail, Src) {
  if (is_not_binary($Src)) {
        $FAIL($Fail);
    }
}

x64.is_bitstring(Fail, Src);

is_float(Fail, Src) {
    if (is_not_float($Src)) {
        $FAIL($Fail);
    }
}

x64.is_float(Fail, Src);

is_function(Fail, Src) {
    if ( !(is_any_fun($Src)) ) {
        $FAIL($Fail);
    }
}

x64.is_function(Fail, Src);

cold_is_function2(Fail, Fun, Arity) {
    if (erl_is_function(c_p, $Fun, $Arity) != am_true ) {
        $FAIL($Fail);
    }
}

x64.cold_is_function2(Fail, Fun, Arity);

hot_is_function2(Fail, Fun, Arity) {
    if (!is_function2($Fun, $Arity)) {
        $FAIL($Fail);
    }
}

x64.hot_is_function2(Fail, Fun, Arity);

is_integer(Fail, Src) {
    if (is_not_integer($Src)) {
        $FAIL($Fail);
    }
}

x64.is_integer(Fail, Src);

is_list(Fail, Src) {
    if (is_not_list($Src) && is_not_nil($Src)) {
        $FAIL($Fail);
    }
}

x64.is_list(Fail, Src);

is_map(Fail, Src) {
    if (is_not_map($Src)) {
        $FAIL($Fail);
    }
}

x64.is_map(Fail, Src);

is_nil(Fail, Src) {
    if (is_not_nil($Src)) {
        $FAIL($Fail);
    }
}

x64.is_nil(Fail, Src);

is_number(Fail, Src) {
    if (is_not_integer($Src) && is_not_float($Src)) {
        $FAIL($Fail);
    }
}

x64.is_number(Fail, Src);

is_pid(Fail, Src) {
    if (is_not_pid($Src)) {
        $FAIL($Fail);
    }
}

x64.is_pid(Fail, Src);

is_port(Fail, Src) {
    if (is_not_port($Src)) {
        $FAIL($Fail);
    }
}

x64.is_port(Fail, Src);

is_reference(Fail, Src) {
    if (is_not_ref($Src)) {
        $FAIL($Fail);
    }
}

x64.is_reference(Fail, Src);

is_tagged_tuple(Fail, Src, Arityval, Tag) {
    Eterm term = $Src;
    if (!(BEAM_IS_TUPLE(term) &&
          (tuple_val(term))[0] == $Arityval &&
          (tuple_val(term))[1] == $Tag)) {
        $FAIL($Fail);
    }
}

x64.is_tagged_tuple(Fail, Src, Arityval, Tag);

is_tagged_tuple_ff(NotTupleFail, WrongRecordFail, Src, Arityval, Tag) {
    Eterm term = $Src;
    if (is_not_tuple(term)) {
        $FAIL($NotTupleFail);
    } else if (ERTS_UNLIKELY((tuple_val(term))[0] != $Arityval ||
                             (tuple_val(term))[1] != $Tag)) {
        $FAIL($WrongRecordFail);
    }
}

x64.is_tagged_tuple_ff(Fail, RecFail, Src, Arityval, Tag);

is_tuple(Fail, Src) {
    if (is_not_tuple($Src)) {
        $FAIL($Fail);
    }
}

x64.is_tuple(Fail, Src);

is_tuple_of_arity(Fail, Src, Arityval) {
    Eterm term = $Src;
    if (!(BEAM_IS_TUPLE(term) && *tuple_val(term) == $Arityval)) {
        $FAIL($Fail);
    }
}

x64.is_tuple_of_arity(Fail, Src, Arityval);

test_arity(Fail, Pointer, Arity) {
    if (*tuple_val($Pointer) != $Arity) {
        $FAIL($Fail);
    }
}

x64.test_arity(Fail, Pointer, Arity);

i_is_eq_exact_immed(Fail, X, Y) {
    if ($X != $Y) {
        $FAIL($Fail);
    }
}

x64.i_is_eq_exact_immed(Fail, X, Y);

i_is_ne_exact_immed(Fail, X, Y) {
    if ($X == $Y) {
        $FAIL($Fail);
    }
}

x64.i_is_ne_exact_immed(Fail, X, Y);

is_eq_exact(Fail, X, Y) {
    if (!EQ($X, $Y)) {
        $FAIL($Fail);
    }
}

x64.is_eq_exact(Fail, X, Y);

i_is_eq_exact_literal(Fail, Src, Literal) {
    Eterm src = $Src;
    if (is_immed(src) || !eq(src, $Literal)) {
        $FAIL($Fail);
    }
}

x64.i_is_eq_exact_literal(Fail, Src, Literal);

is_ne_exact(Fail, X, Y) {
    if (EQ($X, $Y)) {
        $FAIL($Fail);
    }
}

x64.is_ne_exact(Fail, X, Y);

i_is_ne_exact_literal(Fail, Src, Literal) {
    Eterm src = $Src;
    if (!is_immed(src) && eq(src, $Literal)) {
        $FAIL($Fail);
    }
}

x64.i_is_ne_exact_literal(Fail, Src, Literal);

is_eq(Fail, A, B) {
    Eterm a = $A;
    Eterm b = $B;
    CMP_EQ_ACTION(a, b, $FAIL($Fail));
}

x64.is_eq(Fail, X, Y);

is_ne(Fail, A, B) {
    Eterm a = $A;
    Eterm b = $B;
    CMP_NE_ACTION(a, b, $FAIL($Fail));
}

x64.is_ne(Fail, X, Y);

is_lt(Fail, X, Y) {
    CMP_LT_ACTION($X, $Y, $FAIL($Fail));
}

x64.is_lt(Fail, X, Y);

is_ge(Fail, X, Y) {
    CMP_GE_ACTION($X, $Y, $FAIL($Fail));
}

x64.is_ge(Fail, X, Y);

badarg(Fail) {
    $BADARG($Fail);
    //| -no_next;
}

badmatch(Src) {
    c_p->fvalue = $Src;
    c_p->freason = BADMATCH;
    goto find_func_info;
    //| -no_next;
}

x64.badmatch(Src);

case_end(Src) {
    c_p->fvalue = $Src;
    c_p->freason = EXC_CASE_CLAUSE;
    goto find_func_info;
    //| -no_next;
}

x64.case_end(Src);

if_end() {
    c_p->freason = EXC_IF_CLAUSE;
    goto find_func_info;
    //| -no_next;
}

x64.if_end();

system_limit(Fail) {
    $SYSTEM_LIMIT($Fail);
    //| -no_next;
}

x64.system_limit(Fail);

catch(Y, Fail) {
    c_p->catches++;
    $Y = $Fail;
}

x64.catch(Y, Fail);

catch_end(Y) {
    $try_end($Y);
    if (is_non_value(r(0))) {
        c_p->fvalue = NIL;
        if (x(1) == am_throw) {
            r(0) = x(2);
        } else {
            if (x(1) == am_error) {
                SWAPOUT;
                x(2) = add_stacktrace(c_p, x(2), x(3));
                SWAPIN;
            }
            /* only x(2) is included in the rootset here */
            if (E - HTOP < 3) {
                $GC_SWAPOUT();
                PROCESS_MAIN_CHK_LOCKS(c_p);
                FCALLS -= erts_garbage_collect_nobump(c_p, 3, reg+2, 1, FCALLS);
                ERTS_VERIFY_UNUSED_TEMP_ALLOC(c_p);
                PROCESS_MAIN_CHK_LOCKS(c_p);
                SWAPIN;
            }
            r(0) = TUPLE2(HTOP, am_EXIT, x(2));
            HTOP += 3;
        }
    }
    CHECK_TERM(r(0));
}

x64.catch_end(Y);

try_end(Y) {
    c_p->catches--;
    make_blank($Y);
}

x64.try_end(Y);

try_case(Y) {
    $try_end($Y);
    ASSERT(is_non_value(r(0)));
    c_p->fvalue = NIL;
    r(0) = x(1);
    x(1) = x(2);
    x(2) = x(3);
}

x64.try_case(Y);

try_case_end(Src) {
    c_p->fvalue = $Src;
    c_p->freason = EXC_TRY_CLAUSE;
    goto find_func_info;
    //| -no_next;
}

x64.try_case_end(Src);

i_raise() {
    Eterm raise_trace = x(2);
    Eterm raise_value = x(1);
    struct StackTrace *s;

    c_p->fvalue = raise_value;
    c_p->ftrace = raise_trace;
    s = get_trace_from_exc(raise_trace);
    if (s == NULL) {
        c_p->freason = EXC_ERROR;
    } else {
        c_p->freason = PRIMARY_EXCEPTION(s->freason);
    }
    goto find_func_info;
    //| -no_next
}

x64.i_raise();

build_stacktrace() {
    SWAPOUT;
    x(0) = build_stacktrace(c_p, x(0));
    SWAPIN;
}

x64.build_stacktrace();

raw_raise() {
    //| -no_prefetch
    Eterm class = x(0);
    Eterm value = x(1);
    Eterm stacktrace = x(2);
    Eterm* freason_ptr;

    /*
     * Note that the i_raise instruction will override c_p->freason
     * with the freason field stored inside the StackTrace struct in
     * ftrace. Therefore, we must take care to store the class both
     * inside the StackTrace struct and in c_p->freason (important if
     * the class is different from the class of the original
     * exception).
     */
    freason_ptr = get_freason_ptr_from_exc(stacktrace);

    if (class == am_error) {
        *freason_ptr = c_p->freason = EXC_ERROR & ~EXF_SAVETRACE;
        c_p->fvalue = value;
        c_p->ftrace = stacktrace;
        goto find_func_info;
    } else if (class == am_exit) {
        *freason_ptr = c_p->freason = EXC_EXIT & ~EXF_SAVETRACE;
        c_p->fvalue = value;
        c_p->ftrace = stacktrace;
        goto find_func_info;
    } else if (class == am_throw) {
        *freason_ptr = c_p->freason = EXC_THROWN & ~EXF_SAVETRACE;
        c_p->fvalue = value;
        c_p->ftrace = stacktrace;
        goto find_func_info;
    } else {
        x(0) = am_badarg;
    }
}

x64.raw_raise();

call_error_handler() {

}

x64.call_error_handler();

normal_exit() {

}

x64.normal_exit();

continue_exit() {

}

x64.continue_exit();

error_action_code() {

}

x64.error_action_code();

i_yield() {
    /* This is safe as long as REDS_IN(c_p) is never stored
     * in c_p->arg_reg[0]. It is currently stored in c_p->def_arg_reg[5].
     */
    c_p->arg_reg[0] = am_true;
    c_p->arity = 1; /* One living register (the 'true' return value) */
    SWAPOUT;
    $SET_CP_I_ABS($NEXT_INSTRUCTION);
    c_p->current = NULL;
    goto do_schedule;
    //| -no_next
}

x64.i_yield();

i_hibernate() {
    HEAVY_SWAPOUT;
    if (erts_hibernate(c_p, reg)) {
        FCALLS = c_p->fcalls;
        c_p->flags &= ~F_HIBERNATE_SCHED;
        goto do_schedule;
    } else {
        HEAVY_SWAPIN;
        I = handle_error(c_p, I, reg, bif_trap_export[BIF_hibernate_3].info.mfa);
        goto post_error_handling;
    }
    //| -no_next
}

// This is optimised as an instruction because
// it has to be very very fast.

i_perf_counter() {
    ErtsSysPerfCounter ts;

    ts = erts_sys_perf_counter();
    if (IS_SSMALL(ts)) {
        r(0) = make_small((Sint)ts);
    } else {
        $GC_TEST(0, ERTS_SINT64_HEAP_SIZE(ts), 0);
        r(0) = make_big(HTOP);
#if defined(ARCH_32)
        if (ts >= (((Uint64) 1) << 32)) {
            *HTOP = make_pos_bignum_header(2);
            BIG_DIGIT(HTOP, 0) = (Uint) (ts & ((Uint) 0xffffffff));
            BIG_DIGIT(HTOP, 1) = (Uint) ((ts >> 32) & ((Uint) 0xffffffff));
            HTOP += 3;
        }
        else
#endif
            {
                *HTOP = make_pos_bignum_header(1);
                BIG_DIGIT(HTOP, 0) = (Uint) ts;
                HTOP += 2;
            }
    }
}
