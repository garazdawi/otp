// -*- mode: c; -*-
// #
// # %CopyrightBegin%
// #
// # Copyright Ericsson AB 1997-2016. All Rights Reserved.
// #
// # Licensed under the Apache License, Version 2.0 (the "License");
// # you may not use this file except in compliance with the License.
// # You may obtain a copy of the License at
// #
// #     http://www.apache.org/licenses/LICENSE-2.0
// #
// # Unless required by applicable law or agreed to in writing, software
// # distributed under the License is distributed on an "AS IS" BASIS,
// # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// # See the License for the specific language governing permissions and
// # limitations under the License.
// #
// # %CopyrightEnd%
// #

// label L
// int_code_end
// line I
{
    erts_exit(ERTS_ERROR_EXIT, "meta op\n");
}
// i_func_info I a a I
{
    ErtsCodeInfo *ci = (ErtsCodeInfo*)I;
    c_p->freason = EXC_FUNCTION_CLAUSE;
    c_p->current = &ci->mfa;
    goto handle_error;
}

// i_generic_breakpoint
{
    BeamInstr real_I;
    HEAVY_SWAPOUT;
    real_I = erts_generic_breakpoint(c_p, erts_code_to_codeinfo(I), reg);
    HEAVY_SWAPIN;
    ASSERT(VALID_INSTR(real_I));

    /* Don't need ArgPF() as it is already done */
    Goto(real_I);
}

// i_debug_breakpoint
{
    HEAVY_SWAPOUT;
    I = call_error_handler(c_p, erts_code_to_codemfa(I), reg, am_breakpoint);
    HEAVY_SWAPIN;
    if (I) {
        ArgPF();
        GotoDest(I);
    }
    goto handle_error;
}

// i_return_time_trace
{
    BeamInstr *pc = (BeamInstr *) (UWord) E[0];
    SWAPOUT;
    erts_trace_time_return(c_p, erts_code_to_codeinfo(pc));
    SWAPIN;
    c_p->cp = NULL;
    SET_I((BeamInstr *) cp_val(E[1]));
    E += 2;
    GotoDest(I);
}

// i_return_to_trace
{
    if (IS_TRACED_FL(c_p, F_TRACE_RETURN_TO)) {
        Uint *cpp = (Uint*) E;
        for(;;) {
            ASSERT(is_CP(*cpp));
            if (*cp_val(*cpp) == (BeamInstr) OpCode(return_trace)) {
                do ++cpp; while(is_not_CP(*cpp));
                cpp += 2;
            } else if (*cp_val(*cpp) == (BeamInstr) OpCode(i_return_to_trace)) {
                do ++cpp; while(is_not_CP(*cpp));
            } else break;
        }
        SWAPOUT;		/* Needed for shared heap */
        ERTS_SMP_UNREQ_PROC_MAIN_LOCK(c_p);
        erts_trace_return_to(c_p, cp_val(*cpp));
        ERTS_SMP_REQ_PROC_MAIN_LOCK(c_p);
        SWAPIN;
    }
    c_p->cp = NULL;
    SET_I((BeamInstr *) cp_val(E[0]));
    E += 1;
    GotoDest(I);
}

// return
{
    SET_I(c_p->cp);
    DTRACE_RETURN_FROM_PC(c_p);
    /*
     * We must clear the CP to make sure that a stale value do not
     * create a false module dependcy preventing code upgrading.
     * It also means that we can use the CP in stack backtraces.
     */
    c_p->cp = 0;
    CHECK_TERM(r(0));
    HEAP_SPACE_VERIFIED(0);
    DispatchReturn();
}

// allocate StackNeed=t Live=t
{
    AH(#{StackNeed}, 0, #{Live});
}
// allocate_heap StackNeed=t HeapNeed=I Livet
{
    AH(#{StackNeed}, #{HeapNeed}, #{Live});
}
// allocate_zero StackNeed=t Live=t
{
    AH(#{StackNeed}, 0, #{Live});
    sys_memset(E, NIL, E + #{StackNeed});
}
// allocate_heap_zero StackNeed=t HeapNeed=I Livet
{
    AH(#{StackNeed}, #{HeapNeed}, #{Live});
    sys_memset(E, NIL, E + #{StackNeed});
}
// deallocate Stack=I
{
    /*
     * This instruction is probably never used (because it is combined with a
     * a return). However, a future compiler might for some reason emit a
     * deallocate not followed by a return, and that should work.
     */
    D(#{Stack});
}

// init Y=y
{
    make_blank(#{Y});
}
// init2 Y1=y Y2=y
{
    make_blank(#{Y1});
    make_blank(#{Y2});
}
// init3 Y1=y Y2=y Y3=y
{
    make_blank(#{Y1});
    make_blank(#{Y2});
    make_blank(#{Y3});
}

// i_trim Stack=I
{
    Uint words = #{Stack};
    Uint cp = E[0];

    E += words;
    E[0] = cp;
}

// test_heap NeedHeap=I Live=t
{
    TestHeap(#{NeedHeap}, #{Live});
}

// start_group select_val_bins
{
    BeamInstr *select_val;

// i_select_val_bins Fail=f Src=xy Size=I
    select_val = #{Src};
    goto do_binary_search;

// label: do_binary_search i_select_val_bins
    struct Pairs {
        BeamInstr val;
        BeamInstr* addr;
    };
    struct Pairs* low;
    struct Pairs* high;
    struct Pairs* mid;
    int bdiff; /* int not long because the arrays aren't that large */

    low = (struct Pairs *) (I + ;
    high = low + #{Size};

    /* The pointer subtraction (high-low) below must produce
     * a signed result, because high could be < low. That
     * requires the compiler to insert quite a bit of code.
     *
     * However, high will be > low so the result will be
     * positive. We can use that knowledge to optimise the
     * entire sequence, from the initial comparison to the
     * computation of mid.
     *
     * -- Mikael Pettersson, Acumem AB
     *
     * Original loop control code:
     *
     * while (low < high) {
     *    mid = low + (high-low) / 2;
     *
     */
    while ((bdiff = (int)((char*)high - (char*)low)) > 0) {
        unsigned int boffset = ((unsigned int)bdiff >> 1) & ~(sizeof(struct Pairs)-1);

        mid = (struct Pairs*)((char*)low + boffset);
        if (select_val < mid->val) {
            high = mid;
        } else if (select_val > mid->val) {
            low = mid + 1;
        } else {
            SET_I(READ_F_TARGET(&mid->val - I));
            GotoDest(I);
        }
    }
    SET_I(#{Fail});
    GotoDest(I);
// end
}
// end_group select_val_bins

// start_group select_val_lins
{
     Eterm select_val;

// opcode: i_select_tuple_arity Fail=f Src=xy Size=I
     select_val = #{Src};
     goto do_select_tuple_arity;

// label: do_select_tuple_arity i_select_tuple_arity
     if (is_tuple(select_val)) {
	 select_val = *tuple_val(select_val);
	 goto do_linear_search;
     }
     SET_I(#{Fail});
     GotoDest(I);

// opcode: i_select_val_lins Fail=f Src=xy Size=I
     select_val = #{Src};
     goto do_linear_search;

// label: do_linear_search do_select_tuple_arity|i_select_val_lins
     {
         BeamInstr *vs = I + #[size];
         int ix = 0;

         for(;;) {
	     if (vs[ix+0] >= select_val) { ix += 0; break; }
             if (vs[ix+1] >= select_val) { ix += 1; break; }
             ix += 2;
         }

         if (vs[ix] == select_val) {
             SET_I(READ_F_TARGET(ix + #{Size} + #[size]]);
         } else {
             SET_I(#{Fail});
         }
         GotoDest(I);
     }
// end
 }
// end_group select_val_lins

// start_group select_val2
{
    Eterm select_val2;
// opcode: i_select_tuple_arity2 Fail=f Src=xy V1=A V2=A D1=f D2=f
     select_val2 = #{Src};
     goto do_select_tuple_arity2;

// label: do_select_tuple_arity2 i_select_tuple_arity2
     if (is_not_tuple(select_val2)) {
         goto select_val2_fail;
     }
     select_val2 = *tuple_val(select_val2);
     goto do_select_val2;

// opcode: i_select_val2 Fail=f Src=xy V1=c V2=c D1=f D2=f
     select_val2 = #{Src};
     goto do_select_val2;

// label: do_select_val2 i_select_tuple_arity2|i_select_val2
     if (select_val2 == #{V1}) {
         SET_I(#{D1});
         GotoDest(I);
     } else if (select_val2 == #{V2}) {
         SET_I(#{D2});
         GotoDest(I);
     }
     goto select_val2_fail;

// label: select_val2_fail do_select_val2|do_select_tuple_arity2
     SET_I(#{Fail});
     GotoDest(I);
// end
}
// end_group  select_val2

// start_group jump_on_val_zero
{
    Eterm jump_on_val_zero_index;
// i_jump_on_val_zero Fail=f Src=xy Size=I
    jump_on_val_zero_index = #{Src};
    goto do_jump_on_val_zero_index;

// label: do_jump_on_val_zero_index i_jump_on_val_zero
    if (is_small(jump_on_val_zero_index)) {
	 jump_on_val_zero_index = signed_val(jump_on_val_zero_index);
	 if (jump_on_val_zero_index < #{Size}) {
	     SET_I(READ_F_TARGET(#[size]+jump_on_val_zero_index));
	     GotoDest(I);
	 }
     }
    CALL_I(#{Fail});
    GotoDest(I);
//end
}
// end_group jump_on_val_zero

// i_jump_on_val f y I I
{
    Eterm jump_on_val_index;

// i_jump_on_val Fail=f Src=xy Size=I Offset=I
    jump_on_val_index = #{Src};
    goto do_jump_on_val_index;

// label: do_jump_on_val_index i_jump_on_val
    if (is_small(jump_on_val_index)) {
        jump_on_val_index = (Uint) (signed_val(jump_on_val_index) - #{Offset});
        if (jump_on_val_index < #{Size}) {
            SET_I(READ_F_TARGET(#[size] + jump_on_val_index));
            GotoDest(I);
        }
    }
    SET_I(#{Fail});
    GotoDest(I);
}

// get_list Src=xy H=xy T=xy
// # The following get_list instructions using x(0) are frequently used.
// get_list Src=r H=x T=x
// get_list Src=r H=xr T=y
// get_list Src=x H=r T=x
// get_list Src=r H=xy T=r
{
    Eterm* tmp_ptr = list_val(#{Src});
    Eterm hd, tl;
    hd = CAR(tmp_ptr);
    tl = CDR(tmp_ptr);
    #{H} = hd;
    #{T} = tl;
}
//
// # Old-style catch.
// catch Y=y Fail=f
{
    c_p->catches++;
    yb(Arg(0)) = #{Fail};
}
// catch_end Y=y
{
    c_p->catches--;
    make_blank(#{Y});
    if (is_non_value(r(0))) {
        if (x(1) == am_throw) {
            r(0) = x(2);
        } else {
            if (x(1) == am_error) {
                SWAPOUT;
                x(2) = add_stacktrace(c_p, x(2), x(3));
                SWAPIN;
            }
            /* only x(2) is included in the rootset here */
            if (E - HTOP < 3) {
                SWAPOUT;
                PROCESS_MAIN_CHK_LOCKS(c_p);
                FCALLS -= erts_garbage_collect_nobump(c_p, 3, reg+2, 1, FCALLS);
                ERTS_VERIFY_UNUSED_TEMP_ALLOC(c_p);
                PROCESS_MAIN_CHK_LOCKS(c_p);
                SWAPIN;
            }
            r(0) = TUPLE2(HTOP, am_EXIT, x(2));
            HTOP += 3;
        }
    }
    CHECK_TERM(r(0));
}

// try_end Y=y
{
    c_p->catches--;
    make_blank(#{Y});
    if (is_non_value(r(0))) {
        r(0) = x(1);
        x(1) = x(2);
        x(2) = x(3);
    }
}

// try_case_end Src=s
{
    Eterm try_case_end_val = #{Src};
    c_p->fvalue = try_case_end_val;
    c_p->freason = EXC_TRY_CLAUSE;
    goto find_func_info;
}

// # Destructive set tuple element
// set_tuple_element Src=s Dst=d Pos=P
{
    Eterm element = #{Src};
    Eterm tuple = REG_TARGET(#{Dst});
    Eterm *p;
    ASSERT(is_tuple(tuple));
    p = (Eterm *) ((unsigned char *) tuple_val(tuple) + #{Pos});
    *p = element;
}

// i_get_tuple_element Src=xy Element=P Dest=x
// i_get_tuple_element Src=xy Element=P Dest=y
{
    Eterm* src = ADD_BYTE_OFFSET(tuple_val(#{Src}), #{Element});
    #{Dest} = *src;
}
// i_get_tuple_element2 Src=x Element=P Dest=x
{
    Eterm* src = ADD_BYTE_OFFSET(tuple_val(#{Src}), #{Element});
    Eterm* dst = &(#{Dest});
    Eterm E1, E2;
    E1 = src[0];
    E2 = src[1];
    dst[0] = E1;
    dst[1] = E2;
}
// i_get_tuple_element2y Src=x Element=P D1=y D2=y
{
    Eterm* src = ADD_BYTE_OFFSET(tuple_val(#{Src}), #{Element});
    Eterm E1, E2;
    E1 = src[0];
    E2 = src[1];
    #{D1} = E1;
    #{D2} = E2;
}
// i_get_tuple_element3 Src=x Element=P Dst=x
{
    Eterm* src = ADD_BYTE_OFFSET(tuple_val(#{Src}), #{Element});
    Eterm* dst;
    Eterm E1, E2, E3;
    dst = &(#{Dest});
    E1 = src[0];
    E2 = src[1];
    E3 = src[2];
    dst[0] = E1;
    dst[1] = E2;
    dst[2] = E3;
}
// is_number Fail=f Src=xy
{
    Eterm src = ${Src};
    if (is_not_integer(src) && is_not_float(src)) {
        ClauseFail();
    }
}
// jump Fail=f
{
    SET_I(#{Fail});
    GotoDest(I);
}
// case_end Val=x
{
    Eterm case_end_val = #{Val};
    c_p->fvalue = case_end_val;
    c_p->freason = EXC_CASE_CLAUSE;
    goto find_func_info;
}
// badmatch Val=x
{
    Eterm badmatch_val = #{Val};
    c_p->fvalue = badmatch_val;
    c_p->freason = BADMATCH;
    goto find_func_info;
}
// if_end
{
    c_p->freason = EXC_IF_CLAUSE;
    goto find_func_info;
}
// i_raise
{
    Eterm raise_trace = x(2);
    Eterm raise_value = x(1);
    struct StackTrace *s;

    c_p->fvalue = raise_value;
    c_p->ftrace = raise_trace;
    s = get_trace_from_exc(raise_trace);
    if (s == NULL) {
        c_p->freason = EXC_ERROR;
    } else {
        c_p->freason = PRIMARY_EXCEPTION(s->freason);
    }
    goto find_func_info;
}
// # Internal now, but could be useful to make known to the compiler.
// badarg j
{
    c_p->freason = BADARG;
    goto lb_Cl_error;
}
// system_limit j
{
    c_p->freason = SYSTEM_LIMIT;
    goto lb_Cl_error;
}
// move_jump Fail=f Src=ncxy
{
    r(0) = #{Src};
    ClauseFail();
}
// move_window3 S1=x S2=x S3=x D=y
{
    Eterm xt0, xt1, xt2;
    Eterm *y = &#{D};
    xt0  = #{S1};
    xt1  = #{S2};
    xt2  = #{S3};
    y[0] = xt0;
    y[1] = xt1;
    y[2] = xt2;
}
// move_window4 S1=x S2=x S3=x S4=x D=y
{
    Eterm xt0, xt1, xt2, xt3;
    Eterm *y = &#{D};
    xt0  = #{S1};
    xt1  = #{S2};
    xt2  = #{S3};
    xt3  = #{S4};
    y[0] = xt0;
    y[1] = xt1;
    y[2] = xt2;
    y[3] = xt3;
}
// move_window5 S1=x S2=x S3=x S4=x S5=x D=y
{
    Eterm xt0, xt1, xt2, xt3, xt4;
    Eterm *y = &#{D};
    xt0  = #{S1};
    xt1  = #{S2};
    xt2  = #{S3};
    xt3  = #{S4};
    xt4  = #{S5};
    y[0] = xt0;
    y[1] = xt1;
    y[2] = xt2;
    y[3] = xt3;
    y[4] = xt4;
}
// swap_temp R1=x R2=xy Tmp=x
{
    Eterm V = #{R1};
    #{R1} = #{R2};
    #{R2} = #{Tmp} = V;
}
// swap R1=x R2=xy
{
    Eterm V = #{R1};
    #{R1} = #{R2};
    #{R2} = V;
}
// move_x1 V=c
x(1) = #{V};
// move_x2 V=c
x(2) = #{V};
// move_shift Src=xy D1=x D2=x
// move_shift Src=x D1=y D2=x
// move_shift Src=x D1=x D2=y
Eterm V = Src; D = SD; SD = V;
// move_dup Src=x D1=x D2=xy
// move_dup Src=y D1=x D2=xy
#{D1} = #{D2} = #{Src};
// %macro: move2_par Move2Par -pack
//
// move2_par S1=x D1=y S1=x D2=y
// move2_par S1=y D1=x S1=y D2=x
// move2_par S1=xy D1=x S1=x D2=x
// move2_par S1=xy D1=x S1=x D2=y
// move2_par S1=x D1=x S1=y D2=x
{
    Eterm V1 = #{S1}, V2 = #{S2};
    #{D1} = V1; #{D2} = V2;
}
// move3 S1=x D1=y S2=x D2=y S3=x D3=y
// move3 S1=y D1=x S2=y D2=x S3=y D3=x
// move3 S1=x D1=x S2=x D2=x S3=x D3=x
{
    #{D1} = #{S1}; #{D2} = #{S2}; #{D3} = #{S3};
}
// move Src=xy Dst=xy
// move Src=c  Dst=x
// move Src=n  Dst=x
// # The following move instructions using x(0) are frequently used.
//
// move Src=xyc Dst=r
// move Src=r   Dst=xy
{
    #{Dst} = #{Src};
}
// remove_message
// timeout
// timeout_locked
// i_loop_rec f
// loop_rec_end f
// wait f
// wait_locked f
// wait_unlocked f
// i_wait_timeout f I
// i_wait_timeout f s
// i_wait_timeout_locked f I
// i_wait_timeout_locked f s
// i_wait_error
// i_wait_error_locked
//
// send

// i_is_eq_exact_immed Fail=f V1=rxy V2=c
if (#{V1} != #{V2}) { ClauseFail(); }

// i_is_eq_exact_literal Fail=f V1=xy V2=c
if (!eq(#{V2},#{V1})) { ClauseFail(); }

// %macro: i_is_ne_exact_immed NotEqualImmed -fail_action
// i_is_ne_exact_immed Fail=f V1=xy V2=c
if (#{V1} == #{V2}) { ClauseFail(); }

// i_is_ne_exact_literal f xy c
if (eq(#{V2},#{V1})) { ClauseFail(); }

// is_eq_exact Fail=f V1=x V2=xy
// is_eq_exact Fail=f V1=s V2=s
if (!EQ(#{V1},#{V2})) { ClauseFail(); }

// is_lt Fail=f X=x Y=xc
// is_lt Fail=f X=c Y=x
// is_lt Fail=f X=s Y=s
CMP_LT_ACTION(#{X},#{Y},ClauseFail())

// is_ge f x xc
// is_ge f c x
// is_ge f s s
CMP_GT_ACTION(#{X},#{Y},ClauseFail())

// is_ne_exact Fail=f X=s Y=s
if (EQ(#{X},#{Y})) { ClauseFail(); }

// is_eq Fail=f X=s Y=s
{ CMP_EQ_ACTION(#{X},#{Y},ClauseFail()); }

// %macro: is_ne NotEqual -fail_action
// is_ne Fail=f X=s Y=s
{ CMP_NE_ACTION(#{X},#{Y},ClauseFail()); }

// %macro:i_put_tuple PutTuple -pack -goto:do_put_tuple
// start_group put_tuple
{
    Eterm pt_arity;
// i_put_tuple Dst=xy Arity=I
    #{Dst} = make_tuple(HTOP);
    pt_arity = #{Arity};
    goto do_put_tuple;
// label: do_put_tuple i_put_tuple
{
     Eterm* hp = HTOP;

     *hp++ = make_arityval(pt_arity);

     do {
	 Eterm term = *I++;
	 switch (loader_tag(term)) {
	 case LOADER_X_REG:
	     *hp++ = x(loader_x_reg_index(term));
	     break;
	 case LOADER_Y_REG:
	     *hp++ = y(loader_y_reg_index(term));
	     break;
	 default:
	     *hp++ = term;
	     break;
	 }
     } while (--pt_arity != 0);
     HTOP = hp;
     ArgPF();
     GotoDest(I);
}
// end
}
// end_group put_tuple

// put_list H=xy T=n Dst=x
// put_list xy x x
// put_list xy y x
// # put_list SrcReg Constant Dst
// put_list x c xy
// put_list y c x
// # put_list Constant SrcReg Dst
// put_list c xy x
// # The following put_list instructions using x(0) are frequently used.
// put_list xy r r
// put_list r n rx
// put_list r x xr
// put_list x x r
// put_list s s d
{
   HTOP[0] = #{H}; HTOP[1] = #{T};
   #{Dst} = make_list(HTOP);
   HTOP += 2;
}

// #
// # Some more only used by the emulator
// #
//
// normal_exit
// continue_exit
// apply_bif
// call_nif
// call_error_handler
// error_action_code
// return_trace
{
     ErtsCodeMFA* mfa = (ErtsCodeMFA *)(E[0]);

     SWAPOUT;		/* Needed for shared heap */
     ERTS_SMP_UNREQ_PROC_MAIN_LOCK(c_p);
     erts_trace_return(c_p, mfa, r(0), ERTS_TRACER_FROM_ETERM(E+1)/* tracer */);
     ERTS_SMP_REQ_PROC_MAIN_LOCK(c_p);
     SWAPIN;
     c_p->cp = NULL;
     SET_I((BeamInstr *) cp_val(E[2]));
     E += 3;
     GotoDest(I);
}
// move_return Src=xcn
{
    x(0) = #{Src};
    SET_I(c_p->cp);
    c_p->cp = 0;
    CHECK_TERM(r(0));
    DispatchReturn();
}
// move_deallocate_return Src=xycn D=Q
{
    x(0) = #{Src};
    SET_I(c_p->cp);
    c_p->cp = 0;
    CHECK_TERM(r(0));
    DeallocateReturn(#{D});
}
// deallocate_return D=Q
{ DeallocateReturn(#{D}); }

// test_heap_1_put_list Need=I H=y
{
    TestHeap(#{Need}, 1);
    PutList(#{H}, r(0), r(0), StoreSimpleDest);
}
//
// %macro:is_tagged_tuple IsTaggedTuple -fail_action
// is_tagged_tuple f rxy A a
//
// %macro:is_tuple_of_arity IsTupleOfArity -fail_action
// is_tuple_of_arity f rxy A
//
// %macro: is_tuple IsTuple -fail_action
// is_tuple f rxy
//
// %macro: test_arity IsArity -fail_action
// test_arity f xy A
//
// %macro: is_integer_allocate IsIntegerAllocate -fail_action
// is_integer_allocate f x I I
//
// %macro: is_integer IsInteger -fail_action
// is_integer f xy
//
// %macro: is_list IsList -fail_action
// is_list f xy
//
// %macro:is_nonempty_list_allocate IsNonemptyListAllocate -fail_action -pack
// is_nonempty_list_allocate f rx I t
//
// %macro: is_non_empty_list_test_heap IsNonemptyListTestHeap -fail_action -pack
// is_non_empty_list_test_heap f I t
//
// %macro: is_nonempty_list_get_list IsNonemptyListGetList -fail_action -pack
// is_nonempty_list_get_list f rx x x
//
// %macro: is_nonempty_list IsNonemptyList -fail_action
// is_nonempty_list f xy
//
// %macro: is_atom IsAtom -fail_action
// is_atom f xy
//
// %macro: is_float IsFloat -fail_action
// is_float f xy
//
// %macro: is_nil IsNil -fail_action
// is_nil f xy
//
// %macro: is_binary IsBinary -fail_action
// is_binary f xy
//
// %macro: is_bitstring IsBitstring -fail_action
// is_bitstring f xy
//
// %macro: is_reference IsRef -fail_action
// is_reference f xy
//
// %macro: is_pid IsPid -fail_action
// is_pid f xy
//
// %macro: is_port IsPort -fail_action
// is_port f xy
//
// %macro: is_boolean IsBoolean -fail_action
// is_boolean f xy
//
// %macro: is_function2 IsFunction2 -fail_action
// is_function2 f s s
//
// %macro: allocate_init AllocateInit -pack
// allocate_init t I y
//
// i_yield
//
// i_apply
// i_apply_last P
// i_apply_only
//
// i_apply_fun
// i_apply_fun_last P
// i_apply_fun_only
//
// i_hibernate
//
// i_perf_counter
//
// call_bif e
//
// i_get_hash c I d
// i_get s d
//
// %macro: self Self
// self xy
//
// %macro: node Node
// node xy
//
// i_fast_element j xy I d
//
// i_element j xy s d
//
// bif1 f b s d
// bif1_body b s d
// i_bif2 f b s s d
// i_bif2_body b s s d
//
// #
// # Internal calls.
// #
//
// i_move_call f c
//
// %macro:move_call MoveCall -arg_f -size -nonext
// move_call f xy
//
// i_move_call_last f P c
//
// %macro:move_call_last MoveCallLast -arg_f -nonext -pack
// move_call_last f xy Q
//
// i_move_call_only f c
//
// %macro:move_call_only MoveCallOnly -arg_f -nonext
// move_call_only f x
//
// i_call f
// i_call_last f P
// i_call_only f
//
// i_call_ext e
// i_call_ext_last e P
// i_call_ext_only e
//
// i_move_call_ext c e
// i_move_call_ext_last e P c
// i_move_call_ext_only e c
//
// i_call_fun I
// i_call_fun_last I P
//
// %macro: i_make_fun MakeFun -pack
// i_make_fun I t
//
// %macro: is_function IsFunction -fail_action
// is_function f xy
//
// # ================================================================
// # New bit syntax matching (R11B).
// # ================================================================
//
// i_bs_start_match2 f xy I I d
//
// i_bs_save2 x I
//
// i_bs_restore2 x I
//
// # Matching integers
// i_bs_match_string f x I I
//
// # Fetching integers from binaries.
// i_bs_get_integer_small_imm f x I I d
// i_bs_get_integer_imm f x I I I d
// i_bs_get_integer f I I s s d
// i_bs_get_integer_8 f x d
// i_bs_get_integer_16 f x d
// i_bs_get_integer_32 f x I d
//
// # Fetching binaries from binaries.
//
// %macro: i_bs_get_binary_imm2 BsGetBinaryImm_2 -fail_action -gen_dest
// %macro: i_bs_get_binary2 BsGetBinary_2 -fail_action -gen_dest
// %macro: i_bs_get_binary_all2 BsGetBinaryAll_2 -fail_action -gen_dest
//
// i_bs_get_binary_imm2 f x I I I d
// i_bs_get_binary2 f x I s I d
// i_bs_get_binary_all2 f x I I d
// i_bs_get_binary_all_reuse f x I
//
// %macro: i_bs_get_float2 BsGetFloat2 -fail_action -gen_dest
// i_bs_get_float2 f x I s I d
//
// # Miscellanous
//
// %macro: i_bs_skip_bits_imm2 BsSkipBitsImm2 -fail_action
// i_bs_skip_bits_imm2 f x I
//
// %macro: i_bs_skip_bits2 BsSkipBits2 -fail_action
// i_bs_skip_bits2 f x xy I
//
// %macro: i_bs_skip_bits_all2 BsSkipBitsAll2 -fail_action
// i_bs_skip_bits_all2 f x I
//
// bs_test_zero_tail2 f x
// bs_test_tail_imm2 f x I
//
// bs_test_unit f x I
// bs_test_unit8 f x
//
// bs_context_to_binary x
//
// #
// # Utf8/utf16/utf32 support. (R12B-5)
// #
// i_bs_get_utf8 f x d
// i_bs_get_utf16 f x I d
// i_bs_validate_unicode_retract j s s
//
// #
// # Constructing binaries
// #
//
// i_bs_init_fail xy j I d
//
// i_bs_init_fail_heap s I j I d
//
// i_bs_init I I d
// i_bs_init_heap_bin I I d
//
// i_bs_init_heap I I I d
// i_bs_init_heap_bin_heap I I I d
//
// i_bs_init_bits_fail x j I d
// i_bs_init_bits_fail y j I d
//
// i_bs_init_bits_fail_heap s I j I d
//
// i_bs_init_bits I I d
// i_bs_init_bits_heap I I I d
//
// bs_add j s s I d
//
// bs_init_writable
//
// i_bs_append j I I I s d
// i_bs_private_append j I s s d
//
// #
// # Storing integers into binaries.
// #
//
// %macro: i_new_bs_put_integer NewBsPutInteger
// %macro: i_new_bs_put_integer_imm NewBsPutIntegerImm
//
// i_new_bs_put_integer j s I s
// i_new_bs_put_integer_imm j I I s
//
// #
// # Utf8/utf16/utf32 support. (R12B-5)
// #
//
// i_bs_utf8_size s d
// i_bs_utf16_size s d
// i_bs_put_utf8 j s
// bs_put_utf16 j I s
// i_bs_validate_unicode j s
//
// #
// # Storing floats into binaries.
// #
//
// %macro: i_new_bs_put_float NewBsPutFloat
// %macro: i_new_bs_put_float_imm NewBsPutFloatImm
//
// i_new_bs_put_float j s I s
// i_new_bs_put_float_imm j I I s
//
// #
// # Storing binaries into binaries.
// #
//
// %macro: i_new_bs_put_binary NewBsPutBinary
// i_new_bs_put_binary j s I s
//
// %macro: i_new_bs_put_binary_imm NewBsPutBinaryImm
// i_new_bs_put_binary_imm j I s
//
// %macro: i_new_bs_put_binary_all NewBsPutBinaryAll
// i_new_bs_put_binary_all j s I
//
// #
// # Warning: The i_bs_put_string and i_new_bs_put_string instructions
// # are specially treated in the loader.
// # Don't change the instruction format unless you change the loader too.
// #
//
// bs_put_string I I
//
// #
// # New floating point instructions (R8).
// #
//
// fmove qd l
// fmove l d
//
// fconv d l
//
// i_fadd l l l
// i_fsub l l l
// i_fmul l l l
// i_fdiv l l l
// i_fnegate l l
//
// i_fcheckerror
// fclearerror
//
// #
// # New apply instructions in R10B.
// #
//
// apply I
// apply_last I P
//
// #
// # Map instructions in R17.
// #
//
// new_map d I I
// update_map_assoc j s d I I
// update_map_exact j s d I I
//
// %macro: is_map IsMap -fail_action
// is_map f xy
//
// i_get_map_elements f s I
//
// %macro: i_get_map_element_hash GetMapElementHash -fail_action
// i_get_map_element_hash f xy c I xy
//
// %macro: i_get_map_element GetMapElement -fail_action
// i_get_map_element f xy x xy
//
// i_increment rxy I I d
//
// i_plus j I x xy d
// i_plus j I s s d
//
// i_minus j I x x d
// i_minus j I s s d
//
// i_times j I s s d
//
// i_m_div j I s s d
// i_int_div j I s s d
//
// i_rem j I x x d
// i_rem j I s s d
//
// i_bsl j I s s d
// i_bsr j I s s d
//
// i_band j I x c d
// i_band j I s s d
//
// i_bor j I s s d
// i_bxor j I s s d
//
// i_int_bnot j s I d
//
// i_gc_bif1 j I s I d
//
// i_gc_bif2 j I I s s d
//
// i_gc_bif3 j I I s s d
//
// #
// # R13B03
// #
// on_load
//
// #
// # R14A.
// #
// recv_mark f
//
// i_recv_set
//
